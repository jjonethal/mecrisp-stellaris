\ ymodem
\ **************
\  xmodem 128 byte block csum
\  +---+---+----+-----------+----+
\  |SOH|BNR|#BNR|D00 ... D7F|CSUM|
\  +---+---+----+-----------+----+
\  SOH  - start of head <$01>
\  BNR  - Blocknumber starts at <$01> wraps at <$FF> to <$00> not to 1
\  #BNR - <$FF - BNR>
\  CSUM - arithmetic sum of data bytes modulo 256 (DATA1 + ... + DATA128) % 256
\
\  xmodem 1024 byte clock csum
\  +---+---+----+-------------+----+
\  |STX|BNR|#BNR|D000 ... D3FF|CSUM|
\  +---+---+----+-------------+----+
\  STX  - start of text <$02>
\  BNR  - block number start at <$01> wraps at <$FF> to <$00>
\  #BNR - <$FF - BNR>
\  CSUM - arithmetic sum of data bytes modulo 256 (DATA1 + ... + DATA1024) % 256
\
\  xmodem 128 byte block crc16
\  +---+---+----+-----------+----+----+
\  |SOH|BNR|#BNR|D00 ... D7F|CRCH|CRCL|
\  +---+---+----+-----------+----+----+
\  SOH  - start of head <$01>
\  BNR  - Blocknumber starts at <$01> wraps at <$FF> to <$00> not to 1
\  #BNR - <$FF - BLKNR>
\  CRCH - Crc-16 high byte crc16(DATA1, ... , DATA128)
\  CRCL - Crc-16 low byte crc16(DATA1, ... , DATA128)
\
\  xmodem 1024 byte block crc16
\  +---+---+----+-------------+----+----+
\  |STX|BNR|#BNR|D000 ... D3FF|CRCH|CRCL|
\  +---+---+----+-------------+----+----+
\  STX    - start of text <$02>
\  BLKNR  - Blocknumber starts at <$01> wraps at <$FF> to <$00> not to 1
\  #BLKNR - <$FF - BLKNR>
\  CRC HI - Crc-16 high byte crc16(DATA1, ... , DATA128)
\  CRC LO - Crc-16 low byte crc16(DATA1, ... , DATA128)
\
\  Negotiate packet check : receiver Capabilities
\  
\    RECEIVER                  SENDER ( old csum mode )
\       +---------------<C>--------------->+
\       |     3 Seconds                    |
\       +---------------<C>--------------->+
\       |     3 Seconds                    |
\       +---------------<C>--------------->+
\       |     3 Seconds                    |
\       +---------------<C>--------------->+
\       |     3 Seconds                    |
\       +---------------<NAK>------------->+
\       |   +---+---+----+--------+----+   |
\       +<--|SOH|BNR|#BNR|D00..D7F|CSUM|<--+
\       |   +---+---+----+--------+----+   |
\       |   |$01|$01|$FE |$XX..$XX|$XX |   |
\       |   +---+---+----+--------+----+   |
\       +---------------<ACK>------------->+
\       |   +---+---+----+--------+----+   |
\       +<--|SOH|BNR|#BNR|D00..D7F|CSUM|<--+
\       |   +---+---+----+--------+----+   |
\       V   |$01|$02|$FD |$XX..$XX|$XX |   V
\       |   +---+---+----+--------+----+   |
\       |                                  |
\
\    Receiver : Negotiate Validity Check
\       send 'C', wait 3 seconds , 3 retries 
\         response from Sender SOH or STX -> crc mode
\         no response from Sender         -> csum mode
\
$01 constant <SOH> \ start of 128 byte block
$02 constant <STX> \ start of 1024 byte block
$04 constant <EOT>
$06 constant <ACK>
$15 constant <NAK>
$18 constant <CAN>
$43 constant <C>

: get-stk-val
  STK_VAL @
;


\ crc calculation functions
decimal
: crc1 ( crc c -- crc ) \ update the xmodem crc looped version
  8 lshift   ( crc  c<<8 )
  xor        ( crc' )
  8 0 do
    2*  dup $10000 and ( crc' f )
    if  $1021 xor      ( crc' )
    then
  loop
  $ffff and
  ;

decimal
: crc2 ( crc c -- crc )     \ update xmodem crc
   swap dup                    ( c crc crc )
   $8 rshift swap $8 lshift OR ( c crc )
   XOR                         ( crc )
   dup $ff and 4 rshift xor
   dup $0c lshift xor
   dup $ff and 5 lshift xor
   $ffff and
   ;

: test-crc-data ( crc -- )
  $100 0 do
    i 2dup ( crc c crc c )
    2dup ( crc c crc c crc c )
    crc1 ( crc c crc c crc1 )
    -rot  ( crc c crc1 crc c )
    crc2 ( crc c crc1 crc2 )
    \ ." test " .s
    <> if ." error char: " . ." crc: " dup . cr
    else drop
    then
  loop
  drop
;

: test-crc
  $10000 0 do
    i $3FF and
    0= if
       ." Run " i . cr
    then
    i test-crc-data
  loop
;

$E5CC constant CRC_TEST_RESULT
$FFFF constant CRC_TEST_START
: test-crc-0x1021
  s" 123456789" ( cadr len -- )
;

: perform-crc-test ( fkt-adr -- f )
  CRC_TEST_START  ( f -- f crc )
  test-crc-0x1021 ( f crc -- f crc cstring len ) .s
  over + swap     ( f crc cend cstart ) .s
  do              ( f crc )
    i c@        ( f crc c )
    2 pick      ( f crc c f ) .s
    execute     ( f crc )
  loop
  swap drop       ( crc ) .s
  CRC_TEST_RESULT = dup
  if   ." Test ok " cr
  else ." Test failed " cr
  then
;

: test-crc1
  ['] crc1 perform-crc-test
  drop ;

: test-crc2
  ['] crc2 perform-crc-test
  drop ;

: update-csum ( csum c -- csum ) \ 8 bit checksum
  + $ff and
  ;

: xmit-crc ( adr len -- ) \ xmodem transmit using crc
;

decimal
: emit-blk-nr ( blk -- )
  dup emit -255 + emit
;

decimal
16000000 variable SYS_HZ

decimal
: ms ( ms -- u )           \ calculate milliseconds
  SYS_HZ @ 1000 u*/        \  use SYS_HZ as time base
;

: seconds ( s -- d )
  SYS_HZ @ *
;

: wait-long ( tl th -- )         \ wait for a long time - depends on timer frequency
  systick-run ( tl th -- )
  STK_VAL @ ( tl th  t1 -- )
  begin
    STK_VAL @ ( tl th t1 t2 -- )
    tuck      ( tl th t2 t1 t2 )
    -         ( tl th t2 dt )
    dup 0<    ( tl th t2 dt f )
    if        ( tl th t2 dt )
      STK_LOAD @ 1+ +
    then      ( tl th t2 dt )
    2swap     ( t2 dt tl th )
    rot 0     ( t2 tl th dt 0 )
    d-        ( t2 tl th )
    2dup      ( t2 tl th tl th ) \ 2dup d. cr
    d0<       ( t2 tl th f )
    >r rot r> ( tl th t2 f )
  until       ( tl th t2 )
  2drop drop
;

: wait ( t -- )                 \ wait for a certain amount of systick timer ticks
  systick-run ( t -- )
  STK_VAL @ ( t t1 -- )
  begin
    STK_VAL @ ( t t1 t2 -- )
    tuck      ( t t2 t1 t2 )
    -         ( t t2 dt )
    dup 0<    ( t t2 dt f )
    if        ( t t2 dt )
      STK_LOAD @ 1+ +
    then      ( t t2 dt )
    .s
    rot - negate ( t2 t )
    tuck      ( t t2 t )
  0< until       ( t t2 )
  2drop
;
$80000000 variable dtmax
$7FFFFFFF variable dtmin

: stat ( v -- )
  dup dtmax @ ( v v dtmax )
  > if ( v )
    dup dtmax ! ( v )
  then ( v )
  dup ( v v )
  dtmin @ ( v v dtmin )
  < if ( v )
    dtmin ! ( -- )
  else
    drop  ( -- )
  then
;

\ perform a single time step
\ t is the remaining time
\ t1 is the timestamp related to the time t
\ must be invoked during within one complete timer period
: time-step      ( t1 t -- t2 t')
  swap           ( t t1 )
  STK_VAL @      ( t t1 t2 ) \ ." time-step stk_val " .s
  nop            ( t t1 t2 )               \ workaround for wrong readout
  tuck           ( t t2 t1 t2 )
  -              ( t t2 dt )               \ dt = 0 means timer not yet increased for low sysclock frequency
  dup 0<         ( t t2 dt f )             \ handle timer wrap around
  STK_LOAD @ 1+  ( t t2 dt f STK_LOAD@++ ) \ add timer period when wrap to dt
  and +          ( t t2 dt)                \ only add timer period when dt is negative -> wrap around
  rot            ( t2 dt t )
  - negate       ( t2 t' )
;


\ busy wait for keypress with timeout in systick timer units
: wait-key           ( t -- key|-1 )           \ wait for keypress with timeout return keykode or -1 if timeout
  ?systick-run        ( t       )
  STK_VAL @          ( t t1    ) \ .s key drop
  swap               ( t1 t    )
  begin
    time-step        ( t2  t   ) \ .s 
    dup 0< if        ( t2  t   )
      2drop -1 -1    ( -1 -1   )         \ timeout
    else             ( t2  t   )
      key?           ( t2  t f )
      if             ( t2  t   )         \ keypress detected
        2drop key -1 ( key -1  )         \ adjust stack for exit
      else 0         ( t2 t 0  )         \ no key next loop
      then           ( key -1 | t2 t 0 ) 
    then             ( key -1 | t2 t 0 )
  until              ( key    | t2 t   )
;

\ decimal 320000000 cr hex wait-key
decimal 
: wait-key-60s
  60000 ms wait-key
;


: send-block-csum ( adr len -- k )    \ return receiver response or -1 on 60s timeout
  over + swap     ( end start )
  0 -rot          ( csum end start )
  do              ( csum )
    i c@          ( csum c )          \ fetch next char to transmit
    dup emit      ( csum c )          \ send next char
    update-csum   ( csum )
  loop
  emit            ( )                 \ transmit checksum
  wait-key-60s
;

: xmit-csum-blk          ( adr len blk -- adr len blk resp )
  10 0 do
  <SOH> emit             ( adr len blk )
  dup emit-blk-nr        ( adr len blk )
  -rot                   ( blk adr len )
  2dup                   ( blk adr len adr len )
  send-block-csum        ( blk adr len resp )
  dup <ack> <> while     ( blk adr len resp ) \ ok transfer next block
  dup -1    <> while     ( blk adr len resp ) \ abort no response for 1 minute
  \ try again
  loop
  drop -1                ( blk adr len resp ) \ 10 retries
;

: xmit-csum ( adr len -- ) \ xmodem transmit using checksum
<SOH> emit
;


: xmit ( adr len -- ) \ xmodem transmit
  key
  case
  <C>   of xmit-crc  endof
  <nak> of xmit-csum endof
  endcase
;
