\ rtc handling
\ lse-on

$40023800      constant RCC_Base

RCC_Base $70 + constant RCC_BDCR
  1 16 lshift constant BDRST  \ Backup domain software reset 0 : no reset 1 : reset
  1 15 lshift constant RTCEN  \ RTC clock enable 0: RTC clock disabled 1: RTC clock enabled
  3  8 lshift constant RTCSEL \ RTC clock source selection 0:no clk 1:LSE 2:LSI 3:HSE(RCC_CFGR.RTCPRE)
  1  3 lshift constant LSEMOD \ External low-speed oscillator bypass 0:low power,        1:high drive
  1  2 lshift constant LSEBYP \ External low-speed oscillator bypass
  1  1 lshift constant LSERDY \ External low-speed oscillator ready  0:LSE clk not ready,1: LSE clk ready
  1           constant LSEON  \ External low-speed oscillator enable 0: LSE clk OFF      1: LSE clk ON

$40007000  constant PWR_BASE
PWR_BASE   constant PWR_CR
1 8 lshift constant DBP       \ disable backup protection

: backup-protect-set ( f -- ) \ switch backup protection 1 on 0 off
  not 1 and 8 lshift PWR_CR @ DBP not and or PWR_CR ! ;

: backup-protect-on  ( -- )   \ switch on backup protection
  DBP PWR_CR bic! ;

: backup-protect-off ( -- )   \ switch off backup protection
  DBP PWR_CR bis! ;

: ?backup-protect    ( -- f ) \ query backup protect status
  PWR_CR @ DBP and 0= ;


  
\  we have the value v. we want to have the masked bits shown by m
: shift-mask ( v m -- vv )         \ example v: 00111000 m: 11000 -> vv:11 so mask v by m and shift 3 bits right
  begin                ( v m )      \ debugging stuff below
    dup                ( v m m )    \ cr ." dup: " .s
    0<>                ( v m f )
    over               ( v m f m )
    1 and 0=           ( v m f f )  \ cr ." 1 and 0=: " .s
    and                ( v m f )    \ cr ." and " .s        \ mask out all unrelated bits
  while                ( v m )
    dshr               ( v m1 )     \ cr ." dshr: " .s      \ shift right m and v inserting 0 from top
  repeat and           ( v1 )       \ cr                    \ mask out non related bits
  ;

\ hex $BFFFFFFF $C0000000 shift-mask 2 = .                            \ test shift-mask
\ hex $DFFFFFFF $C0000000 shift-maskd 2 = cr . cr                            \ test shift-mask

: get-bits ( m a -- u ) \ get bits from word shifted to mask
  @ swap shift-mask ;  \ mask bits


: RCC_BDCR. ( -- )                  \ dump RCC_BDCR
 cr ." RCC_BDCR:" cr
 ."  BDRST : " BDRST  RCC_BDCR get-bits . cr
 ."  RTCEN : " RTCEN  RCC_BDCR get-bits . cr
 ."  RTCSEL: " RTCSEL RCC_BDCR get-bits . cr
 ."  LSEMOD: " LSEMOD RCC_BDCR get-bits . cr
 ."  LSEBYP: " LSEBYP RCC_BDCR get-bits . cr
 ."  LSERDY: " LSERDY RCC_BDCR get-bits . cr
 ."  LSEON : " LSEON  RCC_BDCR get-bits . cr
 ;
